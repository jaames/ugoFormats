{"version":3,"file":"ugo-formats.min.js","sources":["../src/util.js","../src/BitmapRenderer.js","../src/UgoImage.js","../src/NtftImage.js","../src/NbfImage.js","../src/NpfImage.js","../src/TmbImage.js","../src/UgoMenu.js"],"sourcesContent":["// convert array of 16-bit rgba5551 colors to 32-bit argb8888\nexport function unpackColors(colors) {\n  var ret = new Uint32Array(colors.length);\n  colors.forEach((value, index) => {\n    let r = value & 0x1f,\n        g = value >> 5  & 0x1f,\n        b = value >> 10 & 0x1f,\n        a = value >> 15 & 0x1;\n    r = r << 3 | (r >> 2);\n    g = g << 3 | (g >> 2);\n    b = b << 3 | (b >> 2);\n    a = a == 0 ? 0x00 : 0xFF;\n    ret[index] = (a << 24) | (r << 16) | (g << 8) | b;\n  });\n  return ret;\n}\n\n// unpack an ugar header, used in npfs, nbfs and ugomenus\nexport function unpackUgarHeader(buffer) {\n  let [magic, sectionCount] = new Uint32Array(buffer, 0, 2);\n  if (magic !== 0x52414755) {\n    return null;\n  } else {\n    return new Uint32Array(buffer, 8, sectionCount);\n  }\n}\n\n// decode base64 utf16 labels used in ugomenus\nexport function decodeLabel(b64) {\n  let bin = window.atob(b64);\n  let bytes = new Uint8Array(bin.length);\n  bytes = bytes.map((b, index) => bin.charCodeAt(index));\n  return String.fromCharCode.apply(null, new Uint16Array(bytes.buffer));\n}\n\n// round number upwards to nearst power of two (2, 4, 8, 16, 32, 64, etc)\nexport function roundToPower(value) {\n  if (value & (value - 1) == 0) {\n    return value;\n  } else {\n    let p = 1;\n    while (1 << p < value) {\n      p += 1;\n    }\n    return 1 << p;\n  }   \n}\n\n// round number to nearest multiple of n\nexport function roundToNearest(value, n) {\n  return Math.ceil(value / n) * n;\n}\n\n// fetch a source url as an arraybuffer, returns a promise\nexport function fetchBuffer(source) {\n  return new Promise((resolve, reject) => {\n    let xhr = new XMLHttpRequest();\n    xhr.open(\"GET\", source, true);\n    xhr.responseType = \"arraybuffer\"; \n    xhr.onreadystatechange = e => {\n      if (xhr.readyState === 4) {\n        if (xhr.status >= 200 && xhr.status < 300) {\n          resolve(xhr.response);\n        } else {\n          reject({\n            type: \"httpError\",\n            status: xhr.status,\n            statusText: xhr.statusText\n          });\n        }\n      }\n    };\n    xhr.send(null);\n  });\n}","import { roundToPower, roundToNearest } from \"./util.js\";\n\n// simple bitmap class for rendering images\n// https://en.wikipedia.org/wiki/BMP_file_format\n\nexport default class BitmapRenderer {\n\n  constructor(width, height, bpp) {\n    this.width = width;\n    this.height = height;\n    this.vWidth = roundToNearest(width, 4);\n    this.vHeight = roundToNearest(height, 4);\n    this.bpp = bpp;\n    this.fileHeader = new DataView(new ArrayBuffer(14));\n    this.fileHeader.setUint16(0, 0x424D); // \"BM\" file magic\n    // using BITMAPINFOHEADER dib header variant:\n    this.dibHeader = new DataView(new ArrayBuffer(40));\n    this.dibHeader.setUint32(0, 40, true);\n    this.dibHeader.setInt32(4, width, true); // width\n    this.dibHeader.setInt32(8, height, true); // height\n    this.dibHeader.setUint16(12, 1, true); // color panes (always 1)\n    this.dibHeader.setUint16(14, bpp, true); // bits per pixel\n    this.dibHeader.setUint32(16, 0, true); // compression method (0 = no compression)\n    this.dibHeader.setUint32(20, (this.vWidth * this.height) / bpp, true); // image data size, (width * height) / bits per pixel\n    this.dibHeader.setUint32(24, 3780, true); // x res, pixel per meter\n    this.dibHeader.setUint32(28, 3780, true); // y res, pixel per meter\n    this.dibHeader.setUint32(32, 0, true); // the number of colors in the color palette, or 0 to default to 2n\n    this.dibHeader.setUint32(36, 0, true); // he number of important colors used, or 0 when every color is important; generally ignored\n  }\n\n  setPalette(paletteData) {\n    let paletteLength = Math.pow(2, this.bpp);\n    let palette = new Uint32Array(paletteLength);\n    for (let index = 0; index < palette.length; index++) {\n      palette[index] = paletteData[index % paletteData.length];\n    }\n    this.palette = palette;\n  }\n\n  setPixels(pixelData) {\n    let pixels;\n    let pixelsLength = this.vWidth * this.height;\n    switch (this.bpp) {\n      case 8:\n        pixels = new Uint8Array(pixelsLength);\n        break;\n      case 32:\n        pixels = new Uint32Array(pixelsLength);\n        break;\n    }\n    // flipnote images are width-padded to the nearest power-of-two\n    // and pixel rows are also stored \"upside down\" compared to bmps\n    // so we have to fix this\n    let w = roundToPower(this.width);\n    for (let y = 0; y < this.height; y++) {\n      let srcOffset = (w * this.height) - ((y + 1) * w);\n      let destOffset = (y * this.width);\n      pixels.set(pixelData.slice(srcOffset, srcOffset + this.width), destOffset);\n    }\n    this.pixels = pixels;\n  }\n\n  getBlob() {\n    let sections = [this.fileHeader.buffer, this.dibHeader.buffer];\n    let headerByteLength = this.fileHeader.byteLength + this.dibHeader.byteLength;\n    switch (this.bpp) {\n      case 1:\n      case 4:\n      case 8:\n        // set file length\n        this.fileHeader.setUint32(2, headerByteLength + this.pixels.byteLength + this.palette.byteLength, true);\n        // set pixel data offset\n        this.fileHeader.setUint32(10, headerByteLength + this.palette.byteLength, true);\n        sections = sections.concat([this.palette.buffer, this.pixels.buffer]);\n        break;\n      case 16:\n      case 32:\n        // set file length\n        this.fileHeader.setUint32(2, headerByteLength + this.pixels.byteLength, true);\n        // set pixel data offset\n        this.fileHeader.setUint32(10, headerByteLength, true);\n        sections = sections.concat([this.pixels.buffer]);\n        break;\n    }\n    return new Blob(sections, {type: \"image/bitmap\"})\n  }\n\n  getUrl() {\n    return window.URL.createObjectURL(this.getBlob());\n  }\n\n  getImage() {\n    var img = new Image(this.width, this.height);\n    img.src = this.getUrl();\n    return img;\n  }\n\n}","import { fetchBuffer } from \"./util.js\";\nimport BitmapRenderer from \"./BitmapRenderer.js\";\n\n// base ugoimage class, all image format classes extend from this\n\nexport default class UgoImage {\n\n  constructor(buffer, type) {\n    this.buffer = buffer;\n    this.PIXEL_TYPE = type;\n  }\n\n  // fetch an asset from a url and pass the instance to a promise\n  static fetch(source) {\n    return fetchBuffer(source).then(data => {\n      return new this(data);\n    });\n  }\n\n  getImage(width, height) {\n    return this.getBitmap(width, height).getImage();\n  };\n\n  getImageUrl(width, height) {\n    return this.getBitmap(width, height).getUrl();\n  }\n\n  getImageBlob(width, height) {\n    return this.getBitmap(width, height).getBlob();\n  }\n\n  getBitmap(width, height) {\n    if (this.PIXEL_TYPE == \"P\") {\n      let bmp = new BitmapRenderer(width, height, 8);\n      bmp.setPalette(this.getPalette());\n      bmp.setPixels(this.getPixels());\n      return bmp;\n    } else if (this.PIXEL_TYPE == \"RGBA\") {\n      let bmp = new BitmapRenderer(width, height, 32);\n      bmp.setPixels(this.getPixels());\n      return bmp;\n    }\n  }\n}","import { unpackColors } from \"./util.js\";\nimport UgoImage from \"./UgoImage.js\";\n\n// NTFT class\n// ntft images are just raw 16-bit rgba5551 pixel data\n// format docs: https://github.com/Flipnote-Collective/flipnote-studio-docs/wiki/.ntft-image-format\n\nexport default class NftfImage extends UgoImage {\n\n  constructor(buffer) {\n    super(buffer, \"RGBA\");\n  }\n\n  getPixels() {\n    let pixelData = new Uint16Array(this.buffer);\n    return unpackColors(pixelData);\n  }\n\n}","import { roundToPower, unpackColors, unpackUgarHeader } from \"./util.js\";\nimport UgoImage from \"./UgoImage.js\";\n\n// NBF image class\n// nbf images are used for background images\n// format docs: https://github.com/Flipnote-Collective/flipnote-studio-docs/wiki/.nbf-image-format  \n\nexport default class NbfImage extends UgoImage {\n\n  constructor(buffer) {\n    super(buffer, \"P\");\n    this.sections = unpackUgarHeader(buffer);\n    this.sections[0] = roundToPower(this.sections[0]);\n  }\n\n  getPalette() {\n    let paletteData = new Uint16Array(this.buffer, 16, this.sections[0]);\n    return unpackColors(paletteData);\n  }\n\n  getPixels() {\n    return new Uint8Array(this.buffer, 16 + this.sections[0], this.sections[1]);\n  }\n\n}","import { roundToPower, unpackColors, unpackUgarHeader } from \"./util.js\";\nimport UgoImage from \"./UgoImage.js\";\n\n// NPF image class\n// npf images are 4 bit with 16 palette slots\n// format docs: https://github.com/Flipnote-Collective/flipnote-studio-docs/wiki/.npf-image-format  \n\nexport default class NpfImage extends UgoImage {\n\n  constructor(buffer) {\n    super(buffer, \"P\");\n    this.sections = unpackUgarHeader(buffer);\n    this.sections[0] = roundToPower(this.sections[0]);   \n  }\n\n  getPalette() {\n    let paletteData = new Uint16Array(this.buffer, 16, this.sections[0]);\n    let unpacked = unpackColors(paletteData);\n    // 1st palette entry in npfs is always transparent\n    unpacked[0] = 0xFFFFFF00;\n    return unpacked;\n  }\n\n  getPixels() {\n    let srcData = new Uint8Array(this.buffer, 16 + this.sections[0], this.sections[1]);\n    let pixelData = new Uint8Array(srcData.length * 2);\n    // npf images are 4 bits per pixel\n    for (let iIndex = 0, oIndex = 0; iIndex < srcData.length; iIndex += 1, oIndex += 2) {\n      let byte = srcData[iIndex];\n      pixelData[oIndex] = byte & 0xF;\n      pixelData[oIndex + 1] = (byte >> 4) & 0xF;\n    }\n    return pixelData;\n  }\n\n}","import UgoImage from \"./UgoImage.js\";\n\n// TODO: palette may need tweaking\nconst TMB_PALETTE = new Uint32Array([\n  0xffffffff, \n  0xff525252,\n  0xffffffff,\n  0xffa5a5a5, \n  0xffff0000,\n  0xff7b0000,\n  0xffff7b7b,\n  0xff00ff00, \n  0xff0000ff,\n  0xff00007b,\n  0xff7b7bff,\n  0xff00ff00, \n  0xffff00ff, \n  0xff00ff00, \n  0xff00ff00, \n  0xff00ff00\n]);\n\n// TMB class\n// tmbs are used for flipnote previews in ugomenus and elsewhere, they're actually just the first 1696 bytes of a flipnote ppm\n// because of this, this classed can be used to get ppm thumbnails too\n// format docs: https://github.com/pbsds/hatena-server/wiki/PPM-format\n\nexport default class TmbImage extends UgoImage {\n\n  constructor(buffer) {\n    super(buffer, \"P\");\n  }\n\n  getImage() {\n    return super.getImage(64, 48);\n  }\n\n  getImageUrl() {\n    return super.getImageUrl(64, 48);\n  }\n\n  getImageBlob() {\n    return super.getImageBlob(64, 48);\n  }\n\n  getPalette() {\n    return TMB_PALETTE;\n  }\n\n  getPixels() {\n    let srcData = new Uint8Array(this.buffer, 0xA0, 0x600);\n    let srcOffset = 0;\n    let pixelData = new Uint8Array(srcData.length * 2);\n    // thumbnail bitmaps use 8 * 8 tiles, and each pixel is 4 bits\n    // for each tile:\n    for (let tileIndex = 0; tileIndex < 48; tileIndex++) {\n      // get tile pos\n      let tileX = tileIndex % 8 * 8;\n      let tileY = Math.floor(tileIndex / 8) * 8;\n      // for each horizontal tile line\n      for (let line = 0; line < 8; line ++) {\n        // for each pixel in line\n        // stride is 2 because this format stored 2 pixels ine ach byte\n        for (let pixel = 0; pixel < 8; pixel += 2) {\n          let destOffset = ((tileY + line) * 64) + (tileX + pixel);\n          let byte = srcData[srcOffset];\n          // cop pixels\n          pixelData[destOffset + 1] = byte >> 4 & 0xF;\n          pixelData[destOffset + 0] = byte & 0xF;\n          srcOffset += 1;\n        }\n      }\n    }\n    return pixelData;\n  }\n\n}","import { unpackUgarHeader, fetchBuffer, decodeLabel, roundToNearest } from \"./util.js\";\nimport NtftImage from \"./NtftImage\";\nimport TmbImage from \"./TmbImage\";\n\n// ugomenu class, used to parse .ugo and .uls files\n// format docs: https://github.com/Flipnote-Collective/flipnote-studio-docs/wiki/.ugo-menu-format\n\nexport default class UgoMenu {\n\n  constructor(buffer) {\n    this.buffer = buffer;\n    this.sections = unpackUgarHeader(buffer);\n    // convert content section to a utf8 string\n    let contents = String.fromCharCode.apply(null, new Uint8Array(buffer, 8 + this.sections.byteLength, this.sections[0]));\n    this.contents = contents.split(\"\\n\").map(item => new UgoMenuItem(item));\n    // find layout info\n    let layoutInfo = this.contents.filter(item => item.type == \"LAYOUT\")[0];\n    if (layoutInfo) {\n      this.layoutType = layoutInfo.layoutType;\n      this.layoutVariant = layoutInfo.layoutVariant;\n    }\n    // TODO: cleanup this bit\n    this.embeds = [];\n    if (this.sections.length > 1) {\n      let embedSize = this.layoutType == 2 ? 1696 : 2048;\n      let start = roundToNearest(16 + this.sections[0], 4)\n      let end = start + this.sections[1];\n      for (let embedOffset = start; embedOffset < end; embedOffset += embedSize) {\n        let embedBuffer = this.buffer.slice(embedOffset, embedOffset + embedSize);\n        this.embeds.push(this.layoutType == 2 ? new TmbImage(embedBuffer) : new UgoMenuNtftImage(embedBuffer));\n      }\n    }\n  }\n\n  static fetch(source) {\n    return fetchBuffer(source).then(data => {\n      return new this(data);\n    });\n  }\n\n  getLayout() {\n    return this.contents.filter(item => item.type == \"LAYOUT\");\n  }\n\n  getMeta() {\n    return this.contents.filter(item => item.type == \"META\");\n  }\n\n  getDropdowns() {\n    return this.contents.filter(item => item.type == \"DROPDOWN\");\n  }\n\n  getButtons() {\n    return this.contents.filter(item => item.type == \"BUTTON\");\n  }\n\n  getMenuItems() {\n    return this.contents.filter(item => item.type == \"MENU_ITEM\");\n  }\n\n}\n\n// wrap ntft class so we dont have to provide the size (ugomenu ntft icons are always 32 * 32)\nclass UgoMenuNtftImage extends NtftImage {\n\n  getImage() {\n    return super.getImage(32, 32);\n  }\n\n}\n\nclass UgoMenuItem {\n\n  constructor(str) {\n    let parts = str.split(\"\\t\");\n    let type = parseInt(parts[0]);\n\n    if (type == 0) {\n      this.type = \"LAYOUT\";\n      this.layoutType = parseInt(parts[1]);\n      this.layoutVariant = parseInt(parts[2]) || undefined;\n    } else if (type == 1) {\n      this.type = \"META\";\n      let isImage = parseInt(parts[1]);\n      this.upperlink = isImage ? parts[2] : undefined;\n      this.uppertitle = isImage ? undefined : decodeLabel(parts[2]);\n      this.uppersubleft = isImage ? undefined : decodeLabel(parts[3]);\n      this.uppersubright = isImage ? undefined : decodeLabel(parts[4]);\n      this.uppersubtop = isImage ? undefined : decodeLabel(parts[5]);\n      this.uppersubbottom = isImage ? undefined : decodeLabel(parts[6]);\n    } else if (type == 2) {\n      this.type = \"DROPDOWN\";\n      this.url = parts[1];\n      this.label = decodeLabel(parts[2]);\n      this.isSelected = parts[3] === \"1\";\n    } else if (type == 3) {\n      this.type = \"BUTTON\";\n      this.url = parts[1];\n      this.label = decodeLabel(parts[2]);\n    } else if (type == 4) {\n      this.type = \"MENU_ITEM\";\n      this.url = parts[1];\n      this.icon = parseInt(parts[2]);\n      this.label = decodeLabel(parts[3]);\n      this.counter = parseInt(parts[4]) || undefined;\n      this.lock = parts[5] == \"1\";\n      this.unknown = parts[6];\n    }\n\n  }\n\n}"],"names":["unpackColors","colors","ret","Uint32Array","length","forEach","value","index","r","g","b","a","unpackUgarHeader","buffer","magic","sectionCount","decodeLabel","b64","bin","window","atob","bytes","Uint8Array","map","charCodeAt","String","fromCharCode","apply","Uint16Array","roundToPower","p","roundToNearest","n","Math","ceil","fetchBuffer","source","Promise","resolve","reject","xhr","XMLHttpRequest","open","responseType","onreadystatechange","e","readyState","status","response","statusText","send","BitmapRenderer","width","height","bpp","vWidth","vHeight","fileHeader","DataView","ArrayBuffer","setUint16","dibHeader","setUint32","setInt32","this","setPalette","paletteData","paletteLength","pow","palette","setPixels","pixelData","pixels","pixelsLength","w","y","srcOffset","destOffset","set","slice","getBlob","sections","headerByteLength","byteLength","concat","Blob","getUrl","URL","createObjectURL","getImage","img","Image","src","UgoImage","type","PIXEL_TYPE","fetch","then","data","getBitmap","getImageUrl","getImageBlob","bmp","getPalette","getPixels","NftfImage","NbfImage","NpfImage","unpacked","srcData","iIndex","oIndex","byte","TMB_PALETTE","TmbImage","super","tileIndex","tileX","tileY","floor","line","let","pixel","UgoMenu","contents","split","item","UgoMenuItem","layoutInfo","filter","layoutType","layoutVariant","embeds","embedSize","start","end","embedOffset","embedBuffer","push","UgoMenuNtftImage","getLayout","getMeta","getDropdowns","getButtons","getMenuItems","NtftImage","str","parts","parseInt","undefined","isImage","upperlink","uppertitle","uppersubleft","uppersubright","uppersubtop","uppersubbottom","url","label","isSelected","icon","counter","lock","unknown"],"mappings":"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"}