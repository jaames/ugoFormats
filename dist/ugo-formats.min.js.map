{"version":3,"file":"ugo-formats.min.js","sources":["../src/util.js","../src/BitmapRenderer.js","../src/UgoImage.js","../src/NtftImage.js","../src/NbfImage.js","../src/NpfImage.js","../src/TmbImage.js","../src/UgoMenu.js"],"sourcesContent":["// convert array of 16-bit rgba5551 colors to 32-bit argb8888\nexport function unpackColors(colors) {\n  var ret = new Uint32Array(colors.length);\n  colors.forEach((value, index) => {\n    let r = value & 0x1f,\n        g = value >> 5  & 0x1f,\n        b = value >> 10 & 0x1f,\n        a = value >> 15 & 0x1;\n    r = r << 3 | (r >> 2);\n    g = g << 3 | (g >> 2);\n    b = b << 3 | (b >> 2);\n    a = a == 0 ? 0x00 : 0xFF;\n    ret[index] = (a << 24) | (r << 16) | (g << 8) | b;\n  });\n  return ret;\n}\n\n// unpack an ugar header, used in npfs, nbfs and ugomenus\nexport function unpackUgarHeader(buffer) {\n  let [magic, sectionCount] = new Uint32Array(buffer, 0, 2);\n  if (magic !== 0x52414755) {\n    return null;\n  } else {\n    return new Uint32Array(buffer, 8, sectionCount);\n  }\n}\n\n// decode base64 utf16 labels used in ugomenus\nexport function decodeLabel(b64) {\n  let bin = window.atob(b64);\n  let bytes = new Uint8Array(bin.length);\n  bytes = bytes.map((b, index) => bin.charCodeAt(index));\n  return String.fromCharCode.apply(null, new Uint16Array(bytes.buffer));\n}\n\n// round number upwards to nearst power of two (2, 4, 8, 16, 32, 64, etc)\nexport function roundToPower(value) {\n  if (value & (value - 1) == 0) {\n    return value;\n  } else {\n    let p = 1;\n    while (1 << p < value) {\n      p += 1;\n    }\n    return 1 << p;\n  }   \n}\n\n// round number to nearest multiple of n\nexport function roundToNearest(value, n) {\n  return Math.ceil(value / n) * n;\n}\n\n// fetch a source url as an arraybuffer, returns a promise\nexport function fetchBuffer(source) {\n  return new Promise((resolve, reject) => {\n    let xhr = new XMLHttpRequest();\n    xhr.open(\"GET\", source, true);\n    xhr.responseType = \"arraybuffer\"; \n    xhr.onreadystatechange = e => {\n      if (xhr.readyState === 4) {\n        if (xhr.status >= 200 && xhr.status < 300) {\n          resolve(xhr.response);\n        } else {\n          reject({\n            type: \"httpError\",\n            status: xhr.status,\n            statusText: xhr.statusText\n          });\n        }\n      }\n    };\n    xhr.send(null);\n  });\n}","import { roundToPower, roundToNearest } from \"./util.js\";\n\n// simple bitmap class for rendering images\n// https://en.wikipedia.org/wiki/BMP_file_format\n\nexport default class BitmapRenderer {\n\n  constructor(width, height, bpp) {\n    this.width = width;\n    this.height = height;\n    this.vWidth = roundToNearest(width, 4);\n    this.vHeight = roundToNearest(height, 4);\n    this.bpp = bpp;\n    this.fileHeader = new DataView(new ArrayBuffer(14));\n    this.fileHeader.setUint16(0, 0x424D); // \"BM\" file magic\n    // using BITMAPV4HEADER dib header variant:\n    this.dibHeader = new DataView(new ArrayBuffer(108));\n    this.dibHeader.setUint32(0, 108, true); // DIB header length\n    this.dibHeader.setInt32(4, width, true); // width\n    this.dibHeader.setInt32(8, height, true); // height\n    this.dibHeader.setUint16(12, 1, true); // color panes (always 1)\n    this.dibHeader.setUint16(14, bpp, true); // bits per pixel\n    this.dibHeader.setUint32(16, 3, true); // compression method (3 = BI_BITFIELDS for rgba, 0 = no compression for 8 bit)\n    this.dibHeader.setUint32(20, (this.vWidth * this.height) / (bpp / 8), true); // image data size, (width * height) / bits per pixel\n    this.dibHeader.setUint32(24, 3780, true); // x res, pixel per meter\n    this.dibHeader.setUint32(28, 3780, true); // y res, pixel per meter\n    this.dibHeader.setUint32(32, 0, true); // the number of colors in the color palette, set by setPalette() method\n    this.dibHeader.setUint32(36, 0, true); // the number of important colors used, or 0 when every color is important; generally ignored\n    this.dibHeader.setUint32(40, 0x00FF0000, true); // red channel bitmask\n    this.dibHeader.setUint32(44, 0x0000FF00, true); // green channel bitmask\n    this.dibHeader.setUint32(48, 0x000000FF, true); // blue channel bitmask\n    this.dibHeader.setUint32(52, 0xFF000000, true); // alpha channel bitmask\n    this.dibHeader.setUint32(56, 0x206E6957, true); // LCS_WINDOWS_COLOR_SPACE, little-endian \"Win \"\n    /// rest can be left as nulls\n  }\n\n  setFilelength(value) {\n    this.fileHeader.setUint32(2, value, true);\n  }\n\n  setPixelOffset(value) {\n    this.fileHeader.setUint32(10, value, true);\n  }\n\n  setCompression(value) {\n    this.dibHeader.setUint32(16, value, true);\n  }\n\n  setPaletteCount(value) {\n    this.dibHeader.setUint32(32, value, true);\n  }\n\n  setPalette(paletteData) {\n    let paletteLength = Math.pow(2, this.bpp);\n    let palette = new Uint32Array(paletteLength);\n    for (let index = 0; index < palette.length; index++) {\n      palette[index] = paletteData[index % paletteData.length];\n    }\n    this.setPaletteCount(paletteLength); // set number of colors in DIB header\n    this.setCompression(0); // set compression to 0 so we're not using 32 bit\n    this.palette = palette;\n  }\n\n  setPixels(pixelData) {\n    let pixels;\n    let pixelsLength = this.vWidth * this.height;\n    switch (this.bpp) {\n      case 8:\n        pixels = new Uint8Array(pixelsLength);\n        break;\n      case 32:\n        pixels = new Uint32Array(pixelsLength);\n        break;\n    }\n    // flipnote images are width-padded to the nearest power-of-two\n    // and pixel rows are also stored \"upside down\" compared to bmps\n    // so we have to fix this\n    let w = roundToPower(this.width);\n    for (let y = 0; y < this.height; y++) {\n      let srcOffset = (w * this.height) - ((y + 1) * w);\n      let destOffset = (y * this.width);\n      pixels.set(pixelData.slice(srcOffset, srcOffset + this.width), destOffset);\n    }\n    this.pixels = pixels;\n  }\n\n  getBlob() {\n    let sections = [this.fileHeader.buffer, this.dibHeader.buffer];\n    let headerByteLength = this.fileHeader.byteLength + this.dibHeader.byteLength;\n    switch (this.bpp) {\n      case 1:\n      case 4:\n      case 8:\n        this.setFilelength(headerByteLength + this.pixels.byteLength + this.palette.byteLength);\n        this.setPixelOffset(headerByteLength + this.palette.byteLength);\n        sections = sections.concat([this.palette.buffer, this.pixels.buffer]);\n        break;\n      case 16:\n      case 32:\n        this.setFilelength(headerByteLength + this.pixels.byteLength);\n        this.setPixelOffset(headerByteLength);\n        sections = sections.concat([this.pixels.buffer]);\n        break;\n    }\n    return new Blob(sections, {type: \"image/bitmap\"})\n  }\n\n  getUrl() {\n    return window.URL.createObjectURL(this.getBlob());\n  }\n\n  getImage() {\n    var img = new Image(this.width, this.height);\n    img.src = this.getUrl();\n    return img;\n  }\n\n}","import { fetchBuffer } from \"./util.js\";\nimport BitmapRenderer from \"./BitmapRenderer.js\";\n\n// base ugoimage class, all image format classes extend from this\n\nexport default class UgoImage {\n\n  constructor(buffer, type) {\n    this.buffer = buffer;\n    this.PIXEL_TYPE = type;\n  }\n\n  // fetch an asset from a url and pass the instance to a promise\n  static fetch(source) {\n    return fetchBuffer(source).then(data => {\n      return new this(data);\n    });\n  }\n\n  getImage(width, height) {\n    return this.getBitmap(width, height).getImage();\n  };\n\n  getImageUrl(width, height) {\n    return this.getBitmap(width, height).getUrl();\n  }\n\n  getImageBlob(width, height) {\n    return this.getBitmap(width, height).getBlob();\n  }\n\n  getBitmap(width, height) {\n    if (this.PIXEL_TYPE == \"P\") {\n      let bmp = new BitmapRenderer(width, height, 8);\n      bmp.setPalette(this.getPalette());\n      bmp.setPixels(this.getPixels());\n      return bmp;\n    } else if (this.PIXEL_TYPE == \"RGBA\") {\n      let bmp = new BitmapRenderer(width, height, 32);\n      bmp.setPixels(this.getPixels());\n      return bmp;\n    }\n  }\n}","import { unpackColors } from \"./util.js\";\nimport UgoImage from \"./UgoImage.js\";\n\n// NTFT class\n// ntft images are just raw 16-bit rgba5551 pixel data\n// format docs: https://github.com/Flipnote-Collective/flipnote-studio-docs/wiki/.ntft-image-format\n\nexport default class NftfImage extends UgoImage {\n\n  constructor(buffer) {\n    super(buffer, \"RGBA\");\n  }\n\n  getPixels() {\n    let pixelData = new Uint16Array(this.buffer);\n    return unpackColors(pixelData);\n  }\n\n}","import { roundToPower, unpackColors, unpackUgarHeader } from \"./util.js\";\nimport UgoImage from \"./UgoImage.js\";\n\n// NBF image class\n// nbf images are used for background images\n// format docs: https://github.com/Flipnote-Collective/flipnote-studio-docs/wiki/.nbf-image-format  \n\nexport default class NbfImage extends UgoImage {\n\n  constructor(buffer) {\n    super(buffer, \"P\");\n    this.sections = unpackUgarHeader(buffer);\n    this.sections[0] = roundToPower(this.sections[0]);\n  }\n\n  getPalette() {\n    let paletteData = new Uint16Array(this.buffer, 16, this.sections[0]);\n    return unpackColors(paletteData);\n  }\n\n  getPixels() {\n    return new Uint8Array(this.buffer, 16 + this.sections[0], this.sections[1]);\n  }\n\n}","import { roundToPower, unpackColors, unpackUgarHeader } from \"./util.js\";\nimport UgoImage from \"./UgoImage.js\";\n\n// NPF image class\n// npf images are 4 bit with 16 palette slots\n// format docs: https://github.com/Flipnote-Collective/flipnote-studio-docs/wiki/.npf-image-format  \n\nexport default class NpfImage extends UgoImage {\n\n  constructor(buffer) {\n    super(buffer, \"P\");\n    this.sections = unpackUgarHeader(buffer);\n    this.sections[0] = roundToPower(this.sections[0]);   \n  }\n\n  getPalette() {\n    let paletteData = new Uint16Array(this.buffer, 16, this.sections[0]);\n    let unpacked = unpackColors(paletteData);\n    // 1st palette entry in npfs is always transparent\n    unpacked[0] = 0xFFFFFF00;\n    return unpacked;\n  }\n\n  getPixels() {\n    let srcData = new Uint8Array(this.buffer, 16 + this.sections[0], this.sections[1]);\n    let pixelData = new Uint8Array(srcData.length * 2);\n    // npf images are 4 bits per pixel\n    for (let iIndex = 0, oIndex = 0; iIndex < srcData.length; iIndex += 1, oIndex += 2) {\n      let byte = srcData[iIndex];\n      pixelData[oIndex] = byte & 0xF;\n      pixelData[oIndex + 1] = (byte >> 4) & 0xF;\n    }\n    return pixelData;\n  }\n\n}","import UgoImage from \"./UgoImage.js\";\n\n// TODO: palette may need tweaking\nconst TMB_PALETTE = new Uint32Array([\n  0xffffffff, \n  0xff525252,\n  0xffffffff,\n  0xffa5a5a5, \n  0xffff0000,\n  0xff7b0000,\n  0xffff7b7b,\n  0xff00ff00, \n  0xff0000ff,\n  0xff00007b,\n  0xff7b7bff,\n  0xff00ff00, \n  0xffff00ff, \n  0xff00ff00, \n  0xff00ff00, \n  0xff00ff00\n]);\n\n// TMB class\n// tmbs are used for flipnote previews in ugomenus and elsewhere, they're actually just the first 1696 bytes of a flipnote ppm\n// because of this, this classed can be used to get ppm thumbnails too\n// format docs: https://github.com/pbsds/hatena-server/wiki/PPM-format\n\nexport default class TmbImage extends UgoImage {\n\n  constructor(buffer) {\n    super(buffer, \"P\");\n  }\n\n  getImage() {\n    return super.getImage(64, 48);\n  }\n\n  getImageUrl() {\n    return super.getImageUrl(64, 48);\n  }\n\n  getImageBlob() {\n    return super.getImageBlob(64, 48);\n  }\n\n  getPalette() {\n    return TMB_PALETTE;\n  }\n\n  getPixels() {\n    let srcData = new Uint8Array(this.buffer, 0xA0, 0x600);\n    let srcOffset = 0;\n    let pixelData = new Uint8Array(srcData.length * 2);\n    // thumbnail bitmaps use 8 * 8 tiles, and each pixel is 4 bits\n    // for each tile:\n    for (let tileIndex = 0; tileIndex < 48; tileIndex++) {\n      // get tile pos\n      let tileX = tileIndex % 8 * 8;\n      let tileY = Math.floor(tileIndex / 8) * 8;\n      // for each horizontal tile line\n      for (let line = 0; line < 8; line ++) {\n        // for each pixel in line\n        // stride is 2 because this format stored 2 pixels ine ach byte\n        for (let pixel = 0; pixel < 8; pixel += 2) {\n          let destOffset = ((tileY + line) * 64) + (tileX + pixel);\n          let byte = srcData[srcOffset];\n          // cop pixels\n          pixelData[destOffset + 1] = byte >> 4 & 0xF;\n          pixelData[destOffset + 0] = byte & 0xF;\n          srcOffset += 1;\n        }\n      }\n    }\n    return pixelData;\n  }\n\n}","import { unpackUgarHeader, fetchBuffer, decodeLabel, roundToNearest } from \"./util.js\";\nimport NtftImage from \"./NtftImage\";\nimport TmbImage from \"./TmbImage\";\n\n// ugomenu class, used to parse .ugo and .uls files\n// format docs: https://github.com/Flipnote-Collective/flipnote-studio-docs/wiki/.ugo-menu-format\n\nexport default class UgoMenu {\n\n  constructor(buffer) {\n    this.buffer = buffer;\n    this.sections = unpackUgarHeader(buffer);\n    // convert content section to a utf8 string\n    let contents = String.fromCharCode.apply(null, new Uint8Array(buffer, 8 + this.sections.byteLength, this.sections[0]));\n    this.contents = contents.split(\"\\n\").map(item => new UgoMenuItem(item));\n    // find layout info\n    let layoutInfo = this.contents.filter(item => item.type == \"LAYOUT\")[0];\n    if (layoutInfo) {\n      this.layoutType = layoutInfo.layoutType;\n      this.layoutVariant = layoutInfo.layoutVariant;\n    }\n    // TODO: cleanup this bit\n    this.embeds = [];\n    if (this.sections.length > 1) {\n      let embedSize = this.layoutType == 2 ? 1696 : 2048;\n      let start = roundToNearest(16 + this.sections[0], 4)\n      let end = start + this.sections[1];\n      for (let embedOffset = start; embedOffset < end; embedOffset += embedSize) {\n        let embedBuffer = this.buffer.slice(embedOffset, embedOffset + embedSize);\n        this.embeds.push(this.layoutType == 2 ? new TmbImage(embedBuffer) : new UgoMenuNtftImage(embedBuffer));\n      }\n    }\n  }\n\n  static fetch(source) {\n    return fetchBuffer(source).then(data => {\n      return new this(data);\n    });\n  }\n\n  getLayout() {\n    return this.contents.filter(item => item.type == \"LAYOUT\");\n  }\n\n  getMeta() {\n    return this.contents.filter(item => item.type == \"META\");\n  }\n\n  getDropdowns() {\n    return this.contents.filter(item => item.type == \"DROPDOWN\");\n  }\n\n  getButtons() {\n    return this.contents.filter(item => item.type == \"BUTTON\");\n  }\n\n  getMenuItems() {\n    return this.contents.filter(item => item.type == \"MENU_ITEM\");\n  }\n\n}\n\n// wrap ntft class so we dont have to provide the size (ugomenu ntft icons are always 32 * 32)\nclass UgoMenuNtftImage extends NtftImage {\n\n  getImage() {\n    return super.getImage(32, 32);\n  }\n\n}\n\nclass UgoMenuItem {\n\n  constructor(str) {\n    let parts = str.split(\"\\t\");\n    let type = parseInt(parts[0]);\n\n    if (type == 0) {\n      this.type = \"LAYOUT\";\n      this.layoutType = parseInt(parts[1]);\n      this.layoutVariant = parseInt(parts[2]) || undefined;\n    } else if (type == 1) {\n      this.type = \"META\";\n      let isImage = parseInt(parts[1]);\n      this.upperlink = isImage ? parts[2] : undefined;\n      this.uppertitle = isImage ? undefined : decodeLabel(parts[2]);\n      this.uppersubleft = isImage ? undefined : decodeLabel(parts[3]);\n      this.uppersubright = isImage ? undefined : decodeLabel(parts[4]);\n      this.uppersubtop = isImage ? undefined : decodeLabel(parts[5]);\n      this.uppersubbottom = isImage ? undefined : decodeLabel(parts[6]);\n    } else if (type == 2) {\n      this.type = \"DROPDOWN\";\n      this.url = parts[1];\n      this.label = decodeLabel(parts[2]);\n      this.isSelected = parts[3] === \"1\";\n    } else if (type == 3) {\n      this.type = \"BUTTON\";\n      this.url = parts[1];\n      this.label = decodeLabel(parts[2]);\n    } else if (type == 4) {\n      this.type = \"MENU_ITEM\";\n      this.url = parts[1];\n      this.icon = parseInt(parts[2]);\n      this.label = decodeLabel(parts[3]);\n      this.counter = parseInt(parts[4]) || undefined;\n      this.lock = parts[5] == \"1\";\n      this.unknown = parts[6];\n    }\n\n  }\n\n}"],"names":["unpackColors","colors","ret","Uint32Array","length","forEach","value","index","r","g","b","a","unpackUgarHeader","buffer","magic","sectionCount","decodeLabel","b64","bin","window","atob","bytes","Uint8Array","map","charCodeAt","String","fromCharCode","apply","Uint16Array","roundToPower","p","roundToNearest","n","Math","ceil","fetchBuffer","source","Promise","resolve","reject","xhr","XMLHttpRequest","open","responseType","onreadystatechange","e","readyState","status","response","statusText","send","BitmapRenderer","width","height","bpp","vWidth","vHeight","fileHeader","DataView","ArrayBuffer","setUint16","dibHeader","setUint32","setInt32","this","setFilelength","setPixelOffset","setCompression","setPaletteCount","setPalette","paletteData","paletteLength","pow","palette","setPixels","pixelData","pixels","pixelsLength","w","y","srcOffset","destOffset","set","slice","getBlob","sections","headerByteLength","byteLength","concat","Blob","getUrl","URL","createObjectURL","getImage","img","Image","src","UgoImage","type","PIXEL_TYPE","fetch","then","data","getBitmap","getImageUrl","getImageBlob","bmp","getPalette","getPixels","NftfImage","NbfImage","NpfImage","unpacked","srcData","iIndex","oIndex","byte","TMB_PALETTE","TmbImage","super","tileIndex","tileX","tileY","floor","line","let","pixel","UgoMenu","contents","split","item","UgoMenuItem","layoutInfo","filter","layoutType","layoutVariant","embeds","embedSize","start","end","embedOffset","embedBuffer","push","UgoMenuNtftImage","getLayout","getMeta","getDropdowns","getButtons","getMenuItems","NtftImage","str","parts","parseInt","undefined","isImage","upperlink","uppertitle","uppersubleft","uppersubright","uppersubtop","uppersubbottom","url","label","isSelected","icon","counter","lock","unknown"],"mappings":";;;;;;;sLACO,SAASA,EAAaC,OACvBC,EAAM,IAAIC,YAAYF,EAAOG,iBAC1BC,iBAASC,EAAOC,OACjBC,EAAY,GAARF,EACJG,EAAIH,GAAS,EAAK,GAClBI,EAAIJ,GAAS,GAAK,GAClBK,EAAIL,GAAS,GAAK,IAClBE,GAAK,EAAKA,GAAK,IACfC,GAAK,EAAKA,GAAK,IACfC,GAAK,EAAKA,GAAK,IACV,GAALC,EAAS,EAAO,MAChBJ,GAAUI,GAAK,GAAOH,GAAK,GAAOC,GAAK,EAAKC,IAE3CR,EAIF,SAASU,EAAiBC,SACH,IAAIV,YAAYU,EAAQ,EAAG,wBACzC,aAAVC,EACK,KAEA,IAAIX,YAAYU,EAAQ,EAAGE,GAK/B,SAASC,EAAYC,OACtBC,EAAMC,OAAOC,KAAKH,GAClBI,EAAQ,IAAIC,WAAWJ,EAAId,iBACvBiB,EAAME,aAAKb,EAAGH,UAAUW,EAAIM,WAAWjB,KACxCkB,OAAOC,aAAaC,MAAM,KAAM,IAAIC,YAAYP,EAAMR,SAIxD,SAASgB,EAAavB,MACvBA,EAASA,EAAQ,GAAM,SAClBA,UAEHwB,EAAI,EACD,GAAKA,EAAIxB,MACT,SAEA,GAAKwB,EAKT,SAASC,EAAezB,EAAO0B,UAC7BC,KAAKC,KAAK5B,EAAQ0B,GAAKA,EAIzB,SAASG,EAAYC,UACnB,IAAIC,iBAASC,EAASC,OACvBC,EAAM,IAAIC,iBACVC,KAAK,MAAON,GAAQ,KACpBO,aAAe,gBACfC,4BAAqBC,GACA,IAAnBL,EAAIM,aACFN,EAAIO,QAAU,KAAOP,EAAIO,OAAS,MAC5BP,EAAIQ,kBAGJ,mBACER,EAAIO,kBACAP,EAAIS,iBAKpBC,KAAK,QCnEb,IAAqBC,WAEPC,EAAOC,EAAQC,QACpBF,MAAQA,OACRC,OAASA,OACTE,OAASxB,EAAeqB,EAAO,QAC/BI,QAAUzB,EAAesB,EAAQ,QACjCC,IAAMA,OACNG,WAAa,IAAIC,SAAS,IAAIC,YAAY,UAC1CF,WAAWG,UAAU,EAAG,YAExBC,UAAY,IAAIH,SAAS,IAAIC,YAAY,WACzCE,UAAUC,UAAU,EAAG,KAAK,QAC5BD,UAAUE,SAAS,EAAGX,GAAO,QAC7BS,UAAUE,SAAS,EAAGV,GAAQ,QAC9BQ,UAAUD,UAAU,GAAI,GAAG,QAC3BC,UAAUD,UAAU,GAAIN,GAAK,QAC7BO,UAAUC,UAAU,GAAI,GAAG,QAC3BD,UAAUC,UAAU,GAAKE,KAAKT,OAASS,KAAKX,QAAWC,EAAM,IAAI,QACjEO,UAAUC,UAAU,GAAI,MAAM,QAC9BD,UAAUC,UAAU,GAAI,MAAM,QAC9BD,UAAUC,UAAU,GAAI,GAAG,QAC3BD,UAAUC,UAAU,GAAI,GAAG,QAC3BD,UAAUC,UAAU,GAAI,UAAY,QACpCD,UAAUC,UAAU,GAAI,OAAY,QACpCD,UAAUC,UAAU,GAAI,KAAY,QACpCD,UAAUC,UAAU,GAAI,YAAY,QACpCD,UAAUC,UAAU,GAAI,WAAY,IAI3CG,mCAAc3D,QACPmD,WAAWK,UAAU,EAAGxD,GAAO,IAGtC4D,oCAAe5D,QACRmD,WAAWK,UAAU,GAAIxD,GAAO,IAGvC6D,oCAAe7D,QACRuD,UAAUC,UAAU,GAAIxD,GAAO,IAGtC8D,qCAAgB9D,QACTuD,UAAUC,UAAU,GAAIxD,GAAO,IAGtC+D,gCAAWC,WACLC,EAAgBtC,KAAKuC,IAAI,EAAGR,KAAKV,KACjCmB,EAAU,IAAItE,YAAYoE,GACrBhE,EAAQ,EAAGA,EAAQkE,EAAQrE,OAAQG,MAClCA,GAAS+D,EAAY/D,EAAQ+D,EAAYlE,aAE9CgE,gBAAgBG,QAChBJ,eAAe,QACfM,QAAUA,GAGjBC,+BAAUC,OACJC,EACAC,EAAeb,KAAKT,OAASS,KAAKX,cAC9BW,KAAKV,UACN,IACM,IAAIhC,WAAWuD,cAErB,KACM,IAAI1E,YAAY0E,WAMzBC,EAAIjD,EAAamC,KAAKZ,OACjB2B,EAAI,EAAGA,EAAIf,KAAKX,OAAQ0B,IAAK,KAChCC,EAAaF,OAASzB,QAAY0B,EAAI,GAAKD,EAC3CG,EAAcF,OAAS3B,QACpB8B,IAAIP,EAAUQ,MAAMH,EAAWA,OAAiB5B,OAAQ6B,QAE5DL,OAASA,GAGhBQ,mCACMC,GAAYrB,KAAKP,WAAW5C,OAAQmD,KAAKH,UAAUhD,QACnDyE,EAAmBtB,KAAKP,WAAW8B,WAAavB,KAAKH,UAAU0B,kBAC3DvB,KAAKV,UACN,OACA,OACA,OACEW,cAAcqB,EAAmBtB,KAAKY,OAAOW,WAAavB,KAAKS,QAAQc,iBACvErB,eAAeoB,EAAmBtB,KAAKS,QAAQc,cACzCF,EAASG,QAAQxB,KAAKS,QAAQ5D,OAAQmD,KAAKY,OAAO/D,oBAE1D,QACA,QACEoD,cAAcqB,EAAmBtB,KAAKY,OAAOW,iBAC7CrB,eAAeoB,KACTD,EAASG,QAAQxB,KAAKY,OAAO/D,gBAGrC,IAAI4E,KAAKJ,QAAiB,kBAGnCK,qCACSvE,OAAOwE,IAAIC,gBAAgB5B,KAAKoB,YAGzCS,oCACMC,EAAM,IAAIC,MAAM/B,KAAKZ,MAAOY,KAAKX,iBACjC2C,IAAMhC,KAAK0B,SACRI,GC7GX,IAAqBG,WAEPpF,EAAQqF,QACbrF,OAASA,OACTsF,WAAaD,GAIpBD,EAAOG,eAAMhE,qBACJD,EAAYC,GAAQiE,cAAKC,UACvB,IAAItC,EAAKsC,MAIpBT,8BAASzC,EAAOC,UACPW,KAAKuC,UAAUnD,EAAOC,GAAQwC,YAGvCW,iCAAYpD,EAAOC,UACVW,KAAKuC,UAAUnD,EAAOC,GAAQqC,UAGvCe,kCAAarD,EAAOC,UACXW,KAAKuC,UAAUnD,EAAOC,GAAQ+B,WAGvCmB,+BAAUnD,EAAOC,MACQ,KAAnBW,KAAKmC,WAAmB,KACtBO,EAAM,IAAIvD,EAAeC,EAAOC,EAAQ,YACxCgB,WAAWL,KAAK2C,gBAChBjC,UAAUV,KAAK4C,aACZF,EACF,GAAuB,QAAnB1C,KAAKmC,WAAsB,KAChCO,EAAM,IAAIvD,EAAeC,EAAOC,EAAQ,aACxCqB,UAAUV,KAAK4C,aACZF,ICjCb,IAAqBG,yBAEPhG,eACJA,EAAQ,8IAKPb,EADS,IAAI4B,YAAYoC,KAAKnD,aAPFoF,GCAlBa,yBAEPjG,eACJA,EAAQ,UACTwE,SAAWzE,EAAiBC,QAC5BwE,SAAS,GAAKxD,EAAamC,KAAKqB,SAAS,2IAKvCrF,EADW,IAAI4B,YAAYoC,KAAKnD,OAAQ,GAAImD,KAAKqB,SAAS,8CAK1D,IAAI/D,WAAW0C,KAAKnD,OAAQ,GAAKmD,KAAKqB,SAAS,GAAIrB,KAAKqB,SAAS,QAdtCY,GCAjBc,yBAEPlG,eACJA,EAAQ,UACTwE,SAAWzE,EAAiBC,QAC5BwE,SAAS,GAAKxD,EAAamC,KAAKqB,SAAS,wIAK1C2B,EAAWhH,EADG,IAAI4B,YAAYoC,KAAKnD,OAAQ,GAAImD,KAAKqB,SAAS,cAGxD,GAAK,WACP2B,4CAIHC,EAAU,IAAI3F,WAAW0C,KAAKnD,OAAQ,GAAKmD,KAAKqB,SAAS,GAAIrB,KAAKqB,SAAS,IAC3EV,EAAY,IAAIrD,WAA4B,EAAjB2F,EAAQ7G,QAE9B8G,EAAS,EAAGC,EAAS,EAAGD,EAASD,EAAQ7G,OAAQ8G,GAAU,EAAGC,GAAU,EAAG,KAC9EC,EAAOH,EAAQC,KACTC,GAAiB,GAAPC,IACVD,EAAS,GAAMC,GAAQ,EAAK,UAEjCzC,MAzB2BsB,GCJhCoB,EAAc,IAAIlH,aACtB,WACA,WACA,WACA,WACA,WACA,WACA,WACA,WACA,WACA,WACA,WACA,WACA,WACA,WACA,WACA,aAQmBmH,yBAEPzG,eACJA,EAAQ,0IAIP0G,YAAM1B,mBAAS,GAAI,+CAInB0B,YAAMf,sBAAY,GAAI,gDAItBe,YAAMd,uBAAa,GAAI,8CAIvBY,4CAIHJ,EAAU,IAAI3F,WAAW0C,KAAKnD,OAAQ,IAAM,MAC5CmE,EAAY,EACZL,EAAY,IAAIrD,WAA4B,EAAjB2F,EAAQ7G,QAG9BoH,EAAY,EAAGA,EAAY,GAAIA,YAElCC,EAAQD,EAAY,EAAI,EACxBE,EAAoC,EAA5BzF,KAAK0F,MAAMH,EAAY,GAE1BI,EAAO,EAAGA,EAAO,EAAGA,QAGtBC,IAAIC,EAAQ,EAAGA,EAAQ,EAAGA,GAAS,EAAG,KACrC7C,EAA+B,IAAhByC,EAAQE,IAAeH,EAAQK,GAC9CV,EAAOH,EAAQjC,KAETC,EAAa,GAAKmC,GAAQ,EAAI,KAC9BnC,EAAa,GAAY,GAAPmC,KACf,SAIZzC,MA9C2BsB,GCpBjB8B,WAEPlH,QACLA,OAASA,OACTwE,SAAWzE,EAAiBC,OAE7BmH,EAAWvG,OAAOC,aAAaC,MAAM,KAAM,IAAIL,WAAWT,EAAQ,EAAImD,KAAKqB,SAASE,WAAYvB,KAAKqB,SAAS,UAC7G2C,SAAWA,EAASC,MAAM,MAAM1G,aAAI2G,UAAQ,IAAIC,EAAYD,SAE7DE,EAAapE,KAAKgE,SAASK,gBAAOH,SAAqB,UAAbA,EAAKhC,OAAkB,MACjEkC,SACGE,WAAaF,EAAWE,gBACxBC,cAAgBH,EAAWG,oBAG7BC,UACDxE,KAAKqB,SAASjF,OAAS,UACrBqI,EAA+B,GAAnBzE,KAAKsE,WAAkB,KAAO,KAC1CI,EAAQ3G,EAAe,GAAKiC,KAAKqB,SAAS,GAAI,GAC9CsD,EAAMD,EAAQ1E,KAAKqB,SAAS,GACvBuD,EAAcF,EAAOE,EAAcD,EAAKC,GAAeH,EAAW,KACrEI,OAAmBhI,OAAOsE,MAAMyD,EAAaA,EAAcH,QAC1DD,OAAOM,KAAwB,QAAdR,WAAkB,IAAIhB,EAASuB,GAAe,IAAIE,EAAiBF,MAK/Fd,EAAO3B,eAAMhE,qBACJD,EAAYC,GAAQiE,cAAKC,UACvB,IAAItC,EAAKsC,MAIpB0C,wCACShF,KAAKgE,SAASK,gBAAOH,SAAqB,UAAbA,EAAKhC,QAG3C+C,sCACSjF,KAAKgE,SAASK,gBAAOH,SAAqB,QAAbA,EAAKhC,QAG3CgD,2CACSlF,KAAKgE,SAASK,gBAAOH,SAAqB,YAAbA,EAAKhC,QAG3CiD,yCACSnF,KAAKgE,SAASK,gBAAOH,SAAqB,UAAbA,EAAKhC,QAG3CkD,2CACSpF,KAAKgE,SAASK,gBAAOH,SAAqB,aAAbA,EAAKhC,QAM7C,IAAM6C,wLAGKxB,YAAM1B,mBAAS,GAAI,QAHCwD,GAQzBlB,WAEQmB,OACNC,EAAQD,EAAIrB,MAAM,MAClB/B,EAAOsD,SAASD,EAAM,OAEd,GAARrD,OACGA,KAAO,cACPoC,WAAakB,SAASD,EAAM,SAC5BhB,cAAgBiB,SAASD,EAAM,UAAOE,OACtC,GAAY,GAARvD,EAAW,MACfA,KAAO,WACRwD,EAAUF,SAASD,EAAM,SACxBI,UAAYD,EAAUH,EAAM,QAAKE,OACjCG,WAAaF,OAAUD,EAAYzI,EAAYuI,EAAM,SACrDM,aAAeH,OAAUD,EAAYzI,EAAYuI,EAAM,SACvDO,cAAgBJ,OAAUD,EAAYzI,EAAYuI,EAAM,SACxDQ,YAAcL,OAAUD,EAAYzI,EAAYuI,EAAM,SACtDS,eAAiBN,OAAUD,EAAYzI,EAAYuI,EAAM,SAC7C,GAARrD,QACJA,KAAO,gBACP+D,IAAMV,EAAM,QACZW,MAAQlJ,EAAYuI,EAAM,SAC1BY,WAA0B,MAAbZ,EAAM,IACP,GAARrD,QACJA,KAAO,cACP+D,IAAMV,EAAM,QACZW,MAAQlJ,EAAYuI,EAAM,KACd,GAARrD,SACJA,KAAO,iBACP+D,IAAMV,EAAM,QACZa,KAAOZ,SAASD,EAAM,SACtBW,MAAQlJ,EAAYuI,EAAM,SAC1Bc,QAAUb,SAASD,EAAM,UAAOE,OAChCa,KAAmB,KAAZf,EAAM,QACbgB,QAAUhB,EAAM"}